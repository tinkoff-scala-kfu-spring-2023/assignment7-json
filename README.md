# Json Codecs
Ваша задача реализовать json парсер, используя тайпклассы.
Программа должна уметь парсить из/в Json:
* строки
* целые числа
* числа с плавающей запятой
* листы
* кастомные пользовательские типы
### Json
`Json` может быть отображен нулом, строкой, числами, массивом или json объектом с множеством ранее перечисленных типов
```scala=
sealed trait Json
object Json {
  final case object JsonNull extends Json
  final case class JsonString(value: String) extends Json
  final case class JsonInt(value: Int) extends Json
  final case class JsonDouble(value: Double) extends Json
  final case class JsonArray(value: List[Json]) extends Json
  final case class JsonObject(value: Map[String, Json]) extends Json
}
```
### JsonWriter[A]
Этот тайпкласс может принимать значение типа `А` и трансформировать его в `Json` объект. 
Также у него есть summoner и синтаксическое расширение для вызова `toJson` прямо на объекте типа `А`
### JsonReader
Этот тайпкласс может принимать `Json` и возвращать объект типа `Right(А)`, сконструированный из `Json`.
Если при парсинге возникают ошибки, то они должны аккумулироваться и возвращаться как `Left`

Как вариант, в задание предложено подобное адт ошибок:
* `WrongType` - `JsonReader` нашел поле с нужным именем, но оно оказалось неподходящего типа для конструирования типа `А`.
* `AbsentField` - `JsonReader` не нашел нужного поля в исходном `Json`
* Вы можете дополнять/модифицировать адт ошибок, если считаете предложенное недостаточным. Главное не забудьте отразить новые ошибки в тестах.

### Задание на доп баллы (необязатольное)
1. Если для нужного типа B нет `JsonWriter[B]`, но при этом есть для типа `A :> B`, то должен использоваться `JsonWriter[A]`, который сериализует только те поля, который определены в объекте `A` 
2. Объединить `JsonWriter` и `JsonReader` под одним трейтом `Codec`, который будет уметь сериализовать/десериализовать `Json`, и обладать всеми свойствами из пункта доп задания 1.
3. Подробный трекинг полей с ошибками: 
- Если ридер встречает ошибку в листе сложных элементов, то в ошибке должен содержаться порядковый номер этого элемента и название поля c ошибкой
- Если объект является вложенным в другой объект, то название родительского поля, в котором содержится объект с ошибкой, должно быть добавлено в описание ошибки

Можете использовать любой синтаксис для `Either`/`Validated` или других типов, который найдете подходящим в библиотеке `cats`
Просто импортируйте `cats.data.Validated`/`cats.syntax.either._`/`cats.syntax.validated._` и поисследйте исходный код.
### Полезные ресурсы
* http://typelevel.org/cats/typeclasses.html
* http://typelevel.org/cats/datatypes/validated.html
* http://eed3si9n.com/herding-cats/
